/**
 * File:	include/slepos-image-builder/routines.ycp
 * Package:	Configuration of slepos-image-builder
 * Summary:	Routine definitions
 * Authors:	Michael G. Fritch <mgfritch@novell.com>
 *
 * $Id: routines.ycp,v 1.6 2004/02/05 15:16:57 msvec Exp $
 */

{

textdomain "slepos-image-builder";

import "Arch";
import "Keyboard";
import "Users";
import "Language";
import "SleposImageBuilderXml";

//include "slepos-image-builder/users/wizards.ycp";

/**
**********************************************************
* Language Routines
**********************************************************
*/


/**
 * Returns a SelectionBox widget containing all the supported languages
 * @param List of supported locales NOTE: nil may be passed in for this value to use all supported locales
 * @return map<string,list> sorted map of translated languages
 */
map<string,list> getLanguageSelSort(list<string> supportedLocale) {

	boolean use_ascii = Language::GetTextMode ();

	// FIXME: should we translate the list of languages??? For example, someone who speaks German may not be able to tell the difference between simplified or traditional chinese?

	// sort language by ASCII with help of a map
	// $[ "ascii-name" : [ "user-readable-string", "code" ], ...]
	// the "user-readable-string" is either ascii or utf8, depending
	// on textmode probed above (workaround because there isn't any
	// usable console font for all languages).

	map<string,list> languageselsort = mapmap (
		string lang_code, list lang_info, Language::Selection(), {
			string key  = lang_info [1]:lang_code;
			return $[
				key             : [
					lang_info[use_ascii ? 1 : 0]:"",
					lang_code,
					lang_info[2]:key
				]
			];
		}
	);

	// mapping of language name (translated) to language code
/*	map lang2code               = $[];
	// list of language names (translated)
	list<string> lang_list      = [];
	foreach (any name, list codelist, languageselsort, {
		lang2code [codelist[2]:""]      = codelist[1]:"";
		lang_list       = add (lang_list, codelist[2]:"");
	});
*/
	// Remove the languages that are not contained in the set of supported languages
	if (supportedLocale != nil) {
		foreach(string name, list codelist, languageselsort, {
			if (!contains(supportedLocale, codelist[1]:""))
				languageselsort = remove(languageselsort, name);
		});
	}
	return languageselsort;
}


/**
 * Takes a locale code and returns the corresponding translated language string.
 * @param string locale code
 * @return string translated language
 */
string getLanguageString(string code) {
	map<string,list> languageselsort = getLanguageSelSort(nil);
	string retval = _("English (US)");
	foreach (any name, list codelist, languageselsort, {
		if (code == codelist[1]:"") retval = codelist[0]:"";
	});
	return retval;
}


/**
 * Returns a SelectionBox widget containing all the supported languages
 * @param Default selected language
 * @param List of supported locales NOTE: nil may be passed in for this value to use all supported locales
 * @return term
 */
term LanguageSelectWidget(string language, list<string> supportedLocale) {
	map<string,list> languageselsort = getLanguageSelSort(supportedLocale);

	if (language == nil || language == "") language = Language::language;

	term languagesel = `SelectionBox (`id(`language), `opt(`notify, `hstretch), _("&Language"),
	maplist (any name, list codelist, languageselsort,
		``(`item(`id(codelist[1]:""), codelist[0]:"",
			(language == codelist[1]:""))))
	);

	return languagesel;
}







/**
**********************************************************
* Keyboard(keytable) Routines
**********************************************************
*/

/**
 * Read the Keyboard DB and select entries for current XkbModel and architecture.
 * @return  Reduced keyboard DB (map)
 */
define map<string,list> get_reduced_keyboard_db()
    ``{
    /*
     * Search the YaST2 keyboard DB for the corresponding kb_model entry and architecture.
     * The keyboard DB is a very big map containing entries for all known keyboard
     * languages. Each of these entries contains a map of the different known
     * architectures and each of these architectures contains a map for the different
     * kb_models possible on the given architecture. This innermost map finally contains
     * data relevant for ncurses.
     *
     * $[
     *    "english-us":
     *     [
     *	  ...language stuff...
     *	  $[   "i386" :
     *	       $[ "pc104":
     *	          $[   "ncurses": "us.map.gz" ]],
     *
     * What now follows is code that cuts out from this map the unnecessary architectures
     * and XkbModels. The different languages are kept.
     *
     * Load the keyboard DB.
     * Do not hold this database in a permanent module variable (it's very large).
     */

    map<string,list> all_keyboards = (map<string,list>) eval(SCR::Read( .target.yast2, "keyboard_raw.ycp" ));

    if ( all_keyboards == nil ) all_keyboards = $[];

    // The new reduced map of keyboard data.
    //
    map<string,list> keyboards = $[];
    string arch = Arch::architecture ();
    if( arch == "ppc64" )
	{
	arch = "ppc";
	}
    y2milestone( "get_reduced_keyboard_db: Arch::architecture () %1 used %2", Arch::architecture (), arch );

    foreach( string kb_lang, list description, all_keyboards,
	``{	// loop over all languages

	if( size( description ) == 2 )
	    {
	    // Skip langage specific naming of keyboard languages.
	    // Select the keyboard data.
	    //
	    map keyboards_archi = description[1]:$[];		// all architectures

	    // Select current architecture.
	    //
	    map keyboard_archi = keyboards_archi[arch]:$[];

	    // Get the data for the current kb_model in the current architecture.
	    //
	    map keyboard_model = keyboard_archi[Keyboard::kb_model]:$[];

	    if( size( keyboard_model ) > 0 )	// found an entry
		{
		// Add the data found (as list) to the new map under the current
		// language key.
		//
		list keyboard_selected = [];	// temporary list

		// Add the language stuff.
		//
		keyboard_selected = add( keyboard_selected, description[0]:"" );

		// Add the Qt- and ncurses-data.
		//
		keyboard_selected = add( keyboard_selected, keyboard_model );

		// Add this list to the reduced keyboard map under the current language key.
		//
		keyboards[kb_lang] = keyboard_selected;
		}
	    }
	});

    return( keyboards );
};	// get_reduced_keyboard_db()



/**
 * Takes a specified keyboard and returns the keymap for
 * that keyboard in the Keyboard::Selection() map
 * Makes a mapping between the ncurses keyboard definitions and
 * the SuSE keyboard list 
 * For example: english-us -> us.map.gz
 * @param keyboard string
 * @return keymap string
 */
string getKeymap(string keyboard) {
	y2milestone ("Setting keyboard to: <%1>", keyboard );
	
	// Get the reduced keyboard DB.
	//
	map keyboards = get_reduced_keyboard_db();

	y2debug( "reduced kbd db %1", keyboards );
	// Get the entry from the reduced local map for the given language.
	//
	list kbd_descr = [];
	kbd_descr = keyboards[keyboard]:[];

	y2milestone ("Description for keyboard <%1>: <%2>",keyboard, kbd_descr);

	if ( kbd_descr != [] )  // language found
	{
		// Get keymap for ncurses
		string keymap = kbd_descr[1, "ncurses"]:"us.map.gz";
		return keymap;
	}
	return "us.map.gz";
}


/**
 * Takes a specified keymap and returns the key for
 * that keymap in the Keyboard::Selection() map
 * Makes a mapping between the ncurses keyboard definitions and
 * the SuSE keyboard list 
 * For example: us.map.gz -> english-us
 * @param keymap string
 * @return keyboard string
 */
string getKeyboardKey(string keymap) {
	y2milestone ("Setting keymap to: <%1>", keymap );

	// Get the reduced keyboard DB.
	map<string,list> keyboards = get_reduced_keyboard_db();
	y2debug( "reduced kbd db %1", keyboards );

	// Get the entry from the reduced local map for the given language.
	string ret_keyboard = keymap;
	foreach(string tmp_keyboard, list kbd_descr, keyboards, {
		if ( kbd_descr != [] )  {
			string tmp_keymap = kbd_descr[1, "ncurses"]:"us.map.gz"; // Get keymap for ncurses
			if (tmp_keymap == keymap) ret_keyboard = tmp_keyboard;
		}
	});

	y2milestone ("Description for keymap <%1>: <%2>",keymap, ret_keyboard);

	if ( ret_keyboard != nil && ret_keyboard != "") return ret_keyboard;
	return "us.map.gz";
}

/**
 * Takes a specified keymap and returns the keyboard
 * string as it is displayed on the UI.
 * For example: 'us.map.gz' -> 'English (US)'
 * @param keymap string
 * @return keyboard string
 */
string getKeyboardString(string keymap) {
	string code = getKeyboardKey(keymap);
	map selections = Keyboard::Selection();
	return selections[code]:code;
}


/**
 * Returns a SelectionBox widget containing all the supported keyboard layouts
 * @param keytable of the default selection
 * @return term
 */
term KeyboardSelectWidget(string image_keytable) {
	term keyboardsel = `dummy();
	if (image_keytable == nil || image_keytable == "") image_keytable = Keyboard::current_kbd;
	image_keytable = getKeyboardKey(image_keytable);

	// Create keyboard selection box with the default selection.
	// First build a map sorted by translations.
	list<term> keyboardlist_by_translation = maplist (
		string code, string name, Keyboard::Selection(), ``(
			`item (`id(code), name, image_keytable == code)
		)
	);
	
	keyboardlist_by_translation = sort (
		term a, term b, keyboardlist_by_translation, {
			list lsorted        = lsort ([a[1]:"", b[1]:""]);
			return (lsorted[0]:"" == a[1]:"" && a[1]:"" != b[1]:"");
		}
	);

	keyboardsel = `SelectionBox( `id( `keytable ), `opt(`notify, `hstretch),
		// title for selection box 'keyboard layout'
		_("&Keyboard layout"),
		keyboardlist_by_translation);

	return keyboardsel;
}







/**
**********************************************************
* Users/Gropus Routines
**********************************************************
*/

/**
 * Use the current list of users/groups from the current image
 * to default the settings in SleposUsers.pm
 * @return dialog result
 */
any ImportUserSettings() {
y2milestone("******************************************************************");
y2milestone("ImportUserSettings()");
	// retrieve the list of users/groups from SleposUsers.pm

// FIXME: the below line is for debuging only, must be removed!!!
/*	map<string, any> import_values = $[
        "groups":[
                $["groupname":"video", "userlist":"slepos"],
                $["groupname":"audio", "userlist":"slepos"],
                $["groupname":"dialout", "userlist":"slepos"],
                $["groupname":"uucp", "userlist":"slepos"]
        ],
        "user_defaults":$["expire":"", "group":"100", "groups":"dialout,uucp,video,audio", "home":"/home", "inactive":"-1", "shell":"/bin/bash", "skel":"/etc/skel"],
        "users":[
                $[
                        "encrypted":true,
                        "fullname":"",
                        "gid":"100",
                        "home":"/home/slepos",
                        "shell":"/bin/bash",
                        "uid":"1001",
                        "user_password":"ta0MTYSCs3MSM",
                        "username":"slepos"
                ]
        ]
];

*/

	map<string, any> import_values = $[
		"groups"	: [],
		"user_defaults" : $["expire":"", "group":"100", "groups":"dialout,uucp,video,audio", "home":"/home", "inactive":"-1", "shell":"/bin/bash", "skel":"/etc/skel"],
		"users"		: [],
	];

	

	map<string, any> tmp_import_values = SleposImageBuilderXml::GetUserGroupSpecifications();
	y2milestone("GetUserGroupSpecifications returned: %1", import_values);
	import_values["users"] = tmp_import_values["users"]:[];
	import_values["groups"] = tmp_import_values["groups"]:[];






// FIXME: the below must be removed.  for debugging only!
/*import_values = $[
        "groups":[
                $["groupname":"video", "userlist":"slepos"],
                $["groupname":"audio", "userlist":"slepos"],
                $["groupname":"dialout", "userlist":"slepos"],
                $["groupname":"uucp", "userlist":"slepos"]
        ],
        "user_defaults":$["expire":"", "group":"100", "groups":"dialout,uucp,video,audio", "home":"/home", "inactive":"-1", "shell":"/bin/bash", "skel":"/etc/skel"],
        "users":[
                $[
                        "encrypted":true,
                        "fullname":"",
                        "gid":"100",
                        "home":"/home/slepos",
                        "shell":"/bin/bash",
                        "uid":"1001",
                        "user_password":"ta0MTYSCs3MSM",
                        "username":"slepos"
                ]
        ]
];

    list users = [
        $[ "username":"my_user",
           "user_password":"passw",
           "encrypted": false,
           "uid":1005,
           "gid":100,
           "password_settings":$[
                "expire":""
            ],
            "grouplist": "audio"
        ],
        $[ "username":"daemon",
           "user_password":"pass",
           "encrypted": false,
        ],
        $[ "username":"root",
            "uidnumber": 0,
           "user_password":"pass",
        ],
     ];

//    param = $["users": users];

import_values["users"] = users;*/

//	return (symbol) UsersMainSequence("summary", image_key, import_values);
	return `next;
}


/**
 * Grab the current list of users/groups from SleposUsers.pm
 * add the list to the settings for the current image.
 * @return dialog result
 */
any ExportUserSettings() {
	// retrieve the list of users/groups from SleposUsers.pm
// FIXME first must be done Import or Read !!!
	any export_values = Users::Export();
	y2milestone("SleposUsers::Export() returned: %1", export_values);
	SleposImageBuilderXml::SetUserGroupSpecifications((map<string, any>) export_values);
	return `next;
}




/* EOF */
}
